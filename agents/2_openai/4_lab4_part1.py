# ----------- Standard and Third-Party Imports -----------
import os  # For accessing OS environment variables (like API keys)
import asyncio  # Manage asynchronous execution for concurrent API calls
from typing import Dict, Optional  # For running asynchronous code (lets multiple AI calls happen at once)
import aiohttp
from dotenv import load_dotenv  # Loads environment variables from a .env file for configuration
from openai import AsyncOpenAI  # Asynchronous (non-blocking) client for the OpenAI API
from openai import OpenAIError  # Handles errors that come from calling OpenAI
from agents.model_settings import ModelSettings
from agents import Agent, Runner, OpenAIChatCompletionsModel, Tool, WebSearchTool, set_tracing_disabled, trace, function_tool  # For agent building and tracing
from pydantic import BaseModel, Field
from pydantic_settings import BaseSettings
from sendgrid.helpers.mail import Mail, Email, To, Content  # Helper classes from SendGrid to construct emails (sender, recipient, subject, content)
import sendgrid  # Official SendGrid SDK to send mails using SendGrid API
from string import Template  # For creating string templates with placeholders

# Disable tracing (logging or debugging info) from the 'agents' package, unless you want to debug deeply
# set_tracing_disabled(disabled = True)

# Load anything stored in a .env file as environment variables. Usually used for sensitive configuration.
load_dotenv(override = True)

def validate_env_vars(required_vars : list[str]):
    missing = [var for var in required_vars if not os.getenv(var)]
    if missing:
        raise EnvironmentError(f"Missing required environment variables: {', '.join(missing)}")

# Validate required environment variables before anything else
validate_env_vars(["OPENAI_API_KEY", "SENDGRID_API_KEY"])

# Get the API key from environment variables
openai_api_key = os.getenv("OPENAI_API_KEY")

# Initialize the AsyncOpenAI client with the retrieved credentials
openai_client = AsyncOpenAI(api_key = openai_api_key)

class AgentConfig(BaseSettings):
    how_many_searches : int = 3
    search_context_size : str = "low"
    model_name : str = "gpt-4o-mini"

config = AgentConfig()

class WebSearchItem(BaseModel):
    """
    Represents a single web search task generated by the planner agent.

    Each search item defines one focused direction of inquiry for the overall
    research topic. The goal is to ensure diversity and coverage — each item
    should explore a distinct aspect of the main query.
    """
    
    reason : str = Field(..., 
                         description = """
                         A concise explanation (1-2 sentences) describing why this particular search term 
                         is important or relevant to the user's query. Focus on what unique insight or 
                         dimension it aims to uncover. 
                         """, 
                         examples = ["To understand recent advancements and challenges in battery efficiency for electric vehicles."])
    
    query : str = Field(..., 
                        description = """
                        The exact search phrase or keyword set that should be used when performing 
                        the web search. Keep it specific and information-oriented.
                        """, 
                        examples = ["latest EV battery technology 2024"])


class WebSearchPlan(BaseModel):
    """
    A structured plan consisting of multiple web searches to be performed.

    This model aggregates several `WebSearchItem` objects that, together,
    represent the agent's complete research strategy for answering a user query.
    """
    
    searches : list[WebSearchItem] = Field(..., 
                                           description = """
                                           A list of `WebSearchItem` objects. Each item contains a reason and a 
                                           corresponding query string to search for. The collection should comprehensively 
                                           address the main research query from multiple angles.
                                           """)


class ReportData(BaseModel):
    """
    Represents the final synthesized output produced by the writer agent.

    It includes a short executive summary, a detailed markdown-formatted report,
    and a list of recommended follow-up research questions.
    """
    
    short_summary : str = Field(..., 
                                description = """
                                A concise, 2-3 sentence executive summary of the report's overall findings. 
                                It should capture the key conclusions and essence of the research.
                                """)
    
    markdown_report : str = Field(..., 
                                  description = """
                                  The comprehensive research report written in Markdown format. 
                                  It should include sections, headings, and subheadings (e.g., Introduction, 
                                  Background, Key Insights, Challenges, Future Scope, Conclusion). 
                                  Length: typically 1500-2500 words.
                                  """)
    
    follow_up_questions : list[str] = Field(..., description = """
                                            A list of insightful follow-up questions or subtopics suggested for deeper 
                                            research. Each question should naturally arise from the findings in the report.
                                            """, 
                                            examples = [
                                                "How can organizations mitigate the ethical risks of AI-generated content?", 
                                                "What frameworks exist for evaluating model transparency in large language models?"
                                                ]
                                            )



# ---------------------------------------------------------
# --- Define What Each Agent Should Act Like -------------
# ---------------------------------------------------------
# Here, we are giving "roles" or "personality profiles" to each agent.
# Each is a different kind of sales agent, or a picker who chooses between emails.

agents_config = {
    "Planner Agent" : """
    You are a **Research Planning Agent**.
    
    Your task is to design an effective set of web searches to comprehensively answer a user's query.
    Each search should target a distinct dimension of the topic — such as definitions, history, 
    technical details, trends, case studies, challenges, or future outlook.

    ### Guidelines
    - Generate exactly ${HOW_MANY_SEARCHES} searches.
    - For each search, briefly explain why it is important to the query (1-2 sentences).
    - Ensure the search queries are diverse and information-oriented.
    - Avoid redundant or overly generic search terms.
    - Focus on coverage and research relevance.

    Return your reasoning and search terms according to the required schema (handled automatically).
    """,

    "Search Agent" : """
    You are a **Web Research Agent**.
    
    Given a specific search term and its rationale, perform a focused web search and summarize the findings.

    ### Guidelines
    - Use your web search tool to find the most relevant, up-to-date, and credible information.
    - Produce a concise summary (2-3 paragraphs, under 300 words).
    - Focus only on factual insights, data, or key arguments from top results.
    - Write in clear, note-like sentences — no filler or commentary.
    - Ignore introductions or meta-commentary about the search process.

    Output only the synthesized summary text.
    """,

    "Writer Agent" : """
    You are a **Research Synthesis Agent**.

    Your task is to produce a cohesive, detailed research report based on:
    - The original query.
    - A list of concise search summaries.

    ### Writing Guidelines
    - Begin with a 2-3 sentence executive summary capturing the essence of the findings.
    - Write a full Markdown-formatted report (1500-2500 words).
        Include headings, subheadings, bullet points, and transitions for readability.
    - Structure logically, e.g.: Introduction → Background → Key Insights → Challenges → Future Scope → Conclusion.
    - Maintain an analytical, objective, and professional tone.
    - End by suggesting 3-5 insightful follow-up research questions.

    Return your response in the structured format defined by your output schema.
    """,

    "Email Agent" : """
    You are an **Email Formatting and Delivery Agent**.

    Your goal is to transform a Markdown report into a professional, visually appealing HTML email
    and send it using the `send_html_email(subject, html_body)` tool.

    ### Guidelines
    - Convert the Markdown report into clean, well-structured HTML.
    - Auto-generate a short, relevant subject line for the email.
    - Call `send_html_email` once with:
        - `subject`: your generated subject line.
        - `html_body`: the full formatted report.
    - Include:
        - A header (topic title + current date).
        - Nicely formatted report content.
        - Consistent fonts, spacing, and light colors for readability.
    - Do not output any additional commentary or text — just perform the send action.
    """,
}


def with_retry(max_attempts = 3, delay = 2):
    def decorator(fn):
        async def wrapper(*args, **kwargs):
            for attempt in range(1, max_attempts + 1):
                try:
                    return await fn(*args, **kwargs)
                except Exception as e:
                    print(f"Attempt {attempt} failed for {fn.__name__}: {e}")
                    if attempt < max_attempts:
                        await asyncio.sleep(delay)
                    else:
                        raise
        return wrapper
    return decorator


# ----------------- Function Tool: Send HTML Email -------------------
@function_tool
def send_html_email(subject : str, html_body : str) -> Dict[str, str]:
    """
    Sends an HTML-formatted email using the SendGrid API.

    <b>*Parameters*</b>
    - subject (str): The subject line of the email to be sent.
    - html_body (str): The HTML content that will be used as the body of the email.

    <b>*Returns*</b>
    - Dict[str, str]: A dictionary indicating the status of the operation (e.g., {"status": "success"}).

    <b>*Logic*</b>
    1. Initialize the SendGrid client using the required API key, retrieved securely from environment variables.
    2. Define and validate the sender's email address (must be verified in SendGrid).
    3. Define the recipient's email address.
    4. Construct the email content using the provided HTML body with MIME type "text/html".
    5. Assemble the Mail object with sender, recipient, subject, and HTML content.
    6. Send the email using SendGrid's Mail API with a POST request.
    7. Return a status message indicating the outcome ("success" if the operation was completed).
    """

    # Initialize the SendGrid client using the API key from the environment
    sg = sendgrid.SendGridAPIClient(api_key = os.environ.get("SENDGRID_API_KEY"))

    # Set the verified sender email address (must be verified in your SendGrid dashboard)
    from_email = Email(email = "siddharthwolverine@gmail.com")  # Change this to your verified sender

    # Set the recipient email address (the person who will receive the email)
    to_email = To(email = "siddharth13101999singh@gmail.com")  # Change this to your recipient

    # Define the email content with the given HTML body and the correct MIME type
    content = Content(mime_type = "text/html", content = html_body)

    # Create the email object with sender, recipient, subject, and content
    # Note: Using 'plain_text_content' to store HTML here is a mistake in SendGrid API usage.
    # The correct argument in Mail() is 'html_content' for HTML body, not 'plain_text_content'.
    mail = Mail(from_email = from_email, to_emails = to_email, subject = subject, html_content = content).get()

    # Send the email via the SendGrid client
    sg.client.mail.send.post(request_body = mail)

    # Return a success response
    return {"status" : "success"}


@function_tool
async def custom_web_search(query: str) -> Dict[str, str]:
    """Perform a lightweight web search using DuckDuckGo."""
    async with aiohttp.ClientSession() as session:
        async with session.get("https://api.duckduckgo.com/", params={"q": query, "format": "json"}) as resp:
            data = await resp.json()
    results = [item["Text"] for item in data.get("RelatedTopics", []) if "Text" in item]
    summary = "\n".join(results[:5])
    return {"summary": summary or "No relevant results found."}


planner_agent = Agent(name = "Planner Agent", 
                      instructions = Template(agents_config["Planner Agent"]).substitute(HOW_MANY_SEARCHES = config.how_many_searches), 
                      model = OpenAIChatCompletionsModel(model = config.model_name, openai_client = openai_client), 
                      output_type = WebSearchPlan)

search_agent = Agent(name = "Search Agent", 
                     instructions = agents_config["Search Agent"], 
                     tools = [WebSearchTool(search_context_size = config.search_context_size)], 
                     model = config.model_name, 
                     model_settings = ModelSettings(tool_choice = "required"))

writer_agent = Agent(name = "Writer Agent", 
                     instructions = agents_config["Writer Agent"], 
                     model = OpenAIChatCompletionsModel(model = config.model_name, openai_client = openai_client), 
                     output_type = ReportData)

email_agent = Agent(name = "Email Agent", 
                    instructions = agents_config["Email Agent"], 
                    tools = [send_html_email], 
                    model = OpenAIChatCompletionsModel(model = config.model_name, openai_client = openai_client))

@with_retry()
async def plan_searches(query : str):
    """
    Plans a set of web searches to answer the user's query.

    <b>*Parameters*</b>
    - query (str): The user-provided research query.

    <b>*Returns*</b>
    - WebSearchPlan: A structured plan of searches to perform, containing a list of WebSearchItem objects.

    <b>*Logic*</b>
    1. Logs the start of the planning process.
    2. Uses the planner_agent to generate search items for the given query.
    3. Each search item includes a 'reason' for the search and a 'query' term.
    4. Logs the number of search items planned and their details.
    5. Returns the WebSearchPlan object for further processing.
    """
    
    print("Starting planning of searches...")
    result = await Runner.run(planner_agent, f"Query : {query}")
    
    num_searches = len(result.final_output.searches)
    print(f"Planner created {num_searches} search items.")
    print(f"Search items details: {result.final_output.searches}")

    print("Finished planning searches.")
    return result.final_output


@with_retry()
async def search(item : WebSearchItem):
    """
    Performs a web search for a single search item.

    <b>*Parameters*</b>
    - item (WebSearchItem): An object containing the 'query' term and 'reason' for the search.

    <b>*Returns*</b>
    - str: A short, concise summary (2-3 paragraphs) of the search results.

    <b>*Logic*</b>
    1. Logs the start of the search for the given query.
    2. Constructs input text combining the search term and its reasoning.
    3. Uses the search_agent to retrieve and summarize web content.
    4. Logs completion of the search for tracking.
    5. Returns the summarized search result.
    """
    
    input_text = f"Search term: {item.query}\nReason for searching: {item.reason}"
    print(f"Performing search for query: {item.query}")
    
    # Run the search agent asynchronously
    result = await Runner.run(search_agent, input_text)

    print(f"Completed search for query: {item.query}")
    return result.final_output


@with_retry()
async def perform_searches(search_plan: WebSearchPlan):
    """
    Executes all searches defined in a WebSearchPlan concurrently.

    <b>*Parameters*</b>
    - search_plan (WebSearchPlan): A structured plan containing multiple WebSearchItem objects.

    <b>*Returns*</b>
    - List[str]: A list of summarized results from all searches.

    <b>*Logic*</b>
    1. Logs the start of concurrent search execution.
    2. Creates asyncio tasks for each search item to run them concurrently.
    3. Uses asyncio.gather to wait for all search tasks to finish.
    4. Logs the number of completed searches and optionally their results.
    5. Returns a list of summarized search results for use in report generation.
    """
    
    print("Starting all searches...")

    # Create asyncio tasks for concurrent execution
    tasks = [asyncio.create_task(search(item)) for item in search_plan.searches]
    results = await asyncio.gather(*tasks)

    print(f"All searches completed. Retrieved {len(results)} results.")
    print(f"Search results: {results}")
    return results


@with_retry()
async def write_report(query : str, search_results : list[str]):
    """
    Generates a detailed research report from search results.

    <b>*Parameters*</b>
    - query (str): The original research query provided by the user.
    - search_results (List[str]): List of summarized results from all searches.

    <b>*Returns*</b>
    - ReportData: A structured object containing:
        - short_summary (str)
        - markdown_report (str)
        - follow_up_questions (List[str])

    <b>*Logic*</b>
    1. Logs the start of report preparation.
    2. Constructs input combining the original query and search summaries.
    3. Uses the writer_agent to generate a detailed Markdown-formatted report.
    4. Logs the completion of the report and the short summary.
    5. Returns the ReportData object for email delivery or further processing.
    """
    
    print("Preparing input for report generation...")
    input_text = f"Original query: {query}\nSummarized search results: {search_results}"
    print(f"Input passed to writer agent: {input_text}")

    # Run the writer agent asynchronously
    print("Writing report...")
    result = await Runner.run(writer_agent, input_text)

    print("Report generation completed.")
    print(f"Report summary: {result.final_output.short_summary}")
    return result.final_output


@with_retry()
async def send_email(report : ReportData):
    """
    Sends the generated report as a formatted HTML email.

    <b>*Parameters*</b>
    - report (ReportData): The structured report containing markdown content to be emailed.

    <b>*Returns*</b>
    - ReportData: Returns the same report object after sending email for consistency.

    <b>*Logic*</b>
    1. Logs the start of email generation.
    2. Uses the email_agent to convert the Markdown report into HTML.
    3. Calls the send_html_email tool to send the email with subject and body.
    4. Logs completion of the email sending process.
    5. Returns the report object for reference or further workflow steps.
    """
    
    print("Converting report to email and sending...")
    
    # Run the email agent asynchronously
    await Runner.run(email_agent, report.markdown_report)

    print("Email successfully sent.")
    return report



# ----------- Main Logic Starts Here -------------
async def main(query : str):
    try:
        # -------------------------When using AzureOpenAI-----------------------------------------------------------
        # # Create the Async Azure OpenAI client
        # api_key = os.getenv("azure_openai_api_key")  # Get the API key from environment variables
        # api_version = os.getenv("azure_openai_api_version")  # Get the API version from environment variables
        # azure_endpoint = os.getenv("azure_openai_endpoint")  # Get the Azure endpoint from environment variables

        # # Check if the required environment variables are srt
        # if not all([api_key, api_version, azure_endpoint]):
        #     raise ValueError("One or more required environment variables are not set.")

        # # Initialize the Async Azure OpenAI client with the retrieved credentials
        # client = AsyncAzureOpenAI(azure_endpoint = azure_endpoint, api_version = api_version, api_key = api_key)

        # -------------------------------END------------------------------------------------------------------------
        
        with trace("Research trace"):
            print("Starting research...")
            search_plan = await plan_searches(query)
            search_results = await perform_searches(search_plan)
            report = await write_report(query, search_results)
            await send_email(report)
            print("Hooray!")

    # If the OpenAI API gives an error (e.g., invalid key, network error, quota), show it clearly
    except OpenAIError as openai_err:
        # Handle API-specific errors with an explanatory printout
        print(f"OpenAI API Error : {str(openai_err)}")
    except Exception as general_err:
        # Catch all other unexpected exceptions and display an informative message
        print(f"An unexpected error occurred : {str(general_err)}")


# ---------------------------------------------------------

# --- Script Entry Point ---
if __name__ == "__main__":   
    query = "Latest AI Agent frameworks in 2025"
    # Execute the main asynchronous workflow with all necessary configuration
    asyncio.run(main(query))


# [
#     'In 2025, several AI agent frameworks have been introduced, enhancing the development and deployment of intelligent systems. Dalet\'s "Dalia" integrates agentic AI across its media ecosystem, streamlining workflows like ingest, production, and archiving. Cisco\'s "Connected Intelligence" suite in Webex incorporates AI agents for tasks such as note-taking and scheduling, aiming to boost productivity. OutSystems\' "Agent Workbench" offers a low-code platform for enterprises to implement agentic AI, facilitating automation and modernization of legacy systems. ([tvtechnology.com](https://www.tvtechnology.com/news/dalet-introduces-dalia-agentic-ai-across-entire-ecosystem?utm_source=openai))\n\nIn academia, frameworks like "Agent Lightning" and "AgentScope 1.0" have been developed. "Agent Lightning" enables reinforcement learning-based training of large language model agents, promoting flexibility and extensibility. "AgentScope 1.0" provides a developer-centric environment for building agentic applications, supporting tool-based agent-environment interactions. Additionally, "InfiAgent" introduces a self-evolving pyramid agent framework designed for infinite scenarios, enhancing scalability and adaptability. ([arxiv.org](https://arxiv.org/abs/2508.03680?utm_source=openai))\n\nThe Model Context Protocol (MCP), introduced by Anthropic in November 2024, has gained traction in 2025. MCP standardizes AI system integration with external tools and data sources, with major AI providers like OpenAI and Google DeepMind adopting it. This protocol aims to simplify development in multi-model environments and enhance interoperability. ([en.wikipedia.org](https://en.wikipedia.org/wiki/Model_Context_Protocol?utm_source=openai))\n\nThese developments reflect a growing emphasis on agentic AI frameworks in 2025, aiming to improve automation, scalability, and adaptability across various industries. ',
#     'In 2025, several companies have introduced innovative AI agent frameworks:\n\n- **Dalet** unveiled "Dalia," an Agentic AI solution integrated across its media ecosystem, offering a unified, natural-language interface for tasks like asset management and live ingests. ([tvtechnology.com](https://www.tvtechnology.com/news/dalet-introduces-dalia-agentic-ai-across-entire-ecosystem?utm_source=openai))\n\n- **Cisco** introduced "Connected Intelligence" within its Webex platform, featuring AI agents for tasks such as note-taking, polling, and scheduling, aiming to enhance collaboration workflows. ([techradar.com](https://www.techradar.com/pro/cisco-goes-all-in-on-agents-and-it-could-mean-big-changes-in-your-workplace?utm_source=openai))\n\n- **Verdent AI**, founded by Zhijie Chen, launched a platform designed to manage complex software development through autonomous coding agents, focusing on large-scale planning and coordination. ([techradar.com](https://www.techradar.com/pro/like-spock-supporting-captain-kirk-tiktoks-former-head-of-algo-reveals-platform-that-can-handle-hordes-of-coding-ai-agents-at-scale?utm_source=openai))\n\n- **OutSystems** released Agent Workbench, a low-code platform enabling enterprises to develop and coordinate intelligent agents across various workflows and data sources. ([techradar.com](https://www.techradar.com/pro/outsystems-agent-workbench-reaches-general-availability-helping-enterprises-streamline-operations-through-agentic-ai?utm_source=openai))\n\n- **Okta** hosted Oktane 2025, emphasizing secure AI integration through identity management, introducing the "Identity Security Fabric" and open standards like Cross App Access (XAA). ([techradar.com](https://www.techradar.com/pro/live/oktane-2025-all-the-news-and-updates-as-they-happen?utm_source=openai))\n\n- **H Company** launched Runner H, an agentic-API platform, and Surfer-H-CLI, an open-source Chrome agent for browser-based automation, aiming to automate complex tasks and enhance productivity. ([en.wikipedia.org](https://en.wikipedia.org/wiki/H_%28company%29?utm_source=openai))\n\n- **Pegasystems** introduced the Agentic Process Fabric, designed to manage and govern AI agents across various systems and tasks, enabling seamless integration of agents, apps, systems, and data. ([en.wikipedia.org](https://en.wikipedia.org/wiki/Pegasystems?utm_source=openai))\n\n- **Artisan AI**, founded in 2023, builds specialized AI agents known as "Artisans" for business automation, focusing on automating complex tasks to enhance productivity. ([en.wikipedia.org](https://en.wikipedia.org/wiki/Artisan_AI?utm_source=openai))\n\nAdditionally, academic advancements include:\n\n- **Agent Lightning**, a flexible framework enabling reinforcement learning-based training of large language model agents, allowing seamless integration with existing agents. ([arxiv.org](https://arxiv.org/abs/2508.03680?utm_source=openai))\n\n- **InfiAgent**, a self-evolving pyramid agent framework designed for infinite scenarios, introducing mechanisms like agent-as-a-tool and agent self-evolution for versatile multi-agent systems. ([arxiv.org](https://arxiv.org/abs/2509.22502?utm_source=openai))\n\n- **AutoAgent**, a fully-automated, zero-code framework for large language model agents, enabling users to create and deploy agents through natural language alone. ([arxiv.org](https://arxiv.org/abs/2502.05957?utm_source=openai))\n\nThese developments reflect a growing emphasis on autonomous AI agents across various industries, aiming to streamline operations and enhance productivity. ',
#     "In 2025, AI agent frameworks are evolving to enhance specialization, collaboration, and accessibility. There's a shift towards task-specific agents tailored for domains like healthcare, legal, and marketing, improving accuracy and efficiency. The rise of multi-agent systems enables agents to collaborate, leading to more robust solutions for complex tasks. Additionally, advancements in memory capabilities allow agents to retain context over time, enhancing their ability to handle long-term goals. ([agentiqo.info](https://agentiqo.info/ai-agent-trends-2025/?utm_source=openai))\n\nOpen-source and self-hosted agents are gaining traction, offering organizations greater control over data privacy and customization. Platforms like AutoGPT and Open Interpreter facilitate on-premise hosting and fine-tuning based on internal data, addressing security and compliance concerns. ([agentiqo.info](https://agentiqo.info/ai-agent-trends-2025/?utm_source=openai)) Major tech companies are investing in AI agent platforms to streamline development and deployment. Microsoft's support for the Model Context Protocol (MCP) aims to standardize agent interactions, while AWS's Bedrock AgentCore provides a suite of modular services for scalable AI agent development. ([reuters.com](https://www.reuters.com/business/microsoft-wants-ai-agents-work-together-remember-things-2025-05-19/?utm_source=openai))\n\nThe integration of NoSQL databases is becoming crucial for AI agents, offering flexibility and scalability to manage real-time data and maintain contextual memory. This approach supports the dynamic and adaptive nature of modern AI agents. ([itpro.com](https://www.itpro.com/technology/artificial-intelligence/from-real-time-to-reasoning-why-nosql-is-core-to-agentic-ai?utm_source=openai)) Furthermore, the development of frameworks like Agent Lightning and AutoAgent enables reinforcement learning-based training and zero-code agent creation, making AI agent development more accessible to a broader audience. ([arxiv.org](https://arxiv.org/abs/2508.03680?utm_source=openai))\n\n\n## Recent Developments in AI Agent Frameworks:\n- [OutSystems' Agent Workbench reaches general availability, helping enterprises streamline operations through agentic AI](https://www.techradar.com/pro/outsystems-agent-workbench-reaches-general-availability-helping-enterprises-streamline-operations-through-agentic-ai?utm_source=openai)\n- [From real-time to reasoning: Why NoSQL is core to agentic AI](https://www.itpro.com/technology/artificial-intelligence/from-real-time-to-reasoning-why-nosql-is-core-to-agentic-ai?utm_source=openai)\n- [AWS looks to super-charge AI agents with Amazon Bedrock AgentCore](https://www.techradar.com/pro/aws-looks-to-super-charge-ai-agents-with-amazon-bedrock-agentcore?utm_source=openai) ",
# ]

